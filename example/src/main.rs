use std::fmt;

use iced::widget::{checkbox, column, container, horizontal_space, responsive, scrollable, text};
use iced::{Application, Command, Element, Length, Renderer, Theme};
use iced_table::table::{self, Width};

fn main() {
    App::run(Default::default()).unwrap()
}

#[derive(Debug, Clone)]
pub enum Message {
    SyncHeader(scrollable::AbsoluteOffset),
    Resizing(usize, f32),
    Resized,
    ResizeColumnsEnabled(bool),
    FooterEnabled(bool),
    MinWidthEnabled(bool),
    DarkThemeEnabled(bool),
}

pub struct App {
    columns: Vec<Column>,
    rows: Vec<usize>,
    header: scrollable::Id,
    body: scrollable::Id,
    footer: scrollable::Id,
    resize_columns_enabled: bool,
    footer_enabled: bool,
    min_width_enabled: bool,
    theme: Theme,
}

impl Default for App {
    fn default() -> Self {
        Self {
            columns: vec![
                Column::new(Letter::A, Width::Fixed(100.0)),
                Column::new(
                    Letter::B,
                    Width::Resizable {
                        initial: 100.0,
                        offset: 0.0,
                    },
                ),
                Column::new(
                    Letter::C,
                    Width::Fill {
                        proportion: 2,
                        minimum: 150.0,
                    },
                ),
                Column::new(
                    Letter::D,
                    Width::Fill {
                        proportion: 1,
                        minimum: 100.0,
                    },
                ),
                Column::new(
                    Letter::E,
                    Width::Resizable {
                        initial: 100.0,
                        offset: 0.0,
                    },
                ),
            ],
            rows: (1..=50).collect(),
            header: scrollable::Id::unique(),
            body: scrollable::Id::unique(),
            footer: scrollable::Id::unique(),
            resize_columns_enabled: true,
            footer_enabled: true,
            min_width_enabled: true,
            theme: Theme::Light,
        }
    }
}

impl Application for App {
    type Executor = iced::executor::Default;
    type Message = Message;
    type Theme = Theme;
    type Flags = ();

    fn new(_flags: Self::Flags) -> (Self, Command<Self::Message>) {
        (Self::default(), Command::none())
    }

    fn title(&self) -> String {
        "Iced Table".into()
    }

    fn theme(&self) -> Self::Theme {
        self.theme.clone()
    }

    fn update(&mut self, message: Self::Message) -> Command<Self::Message> {
        match message {
            Message::SyncHeader(offset) => {
                return Command::batch(vec![
                    scrollable::scroll_to(self.header.clone(), offset),
                    scrollable::scroll_to(self.footer.clone(), offset),
                ])
            }
            Message::Resizing(index, offset) => {
                if let Some(column) = self.columns.get_mut(index) {
                    if let Width::Resizable {
                        initial, offset: old_offset
                    } = &mut column.width
                    {
                        *old_offset = (*initial + offset).clamp(50.0, 250.0) - *initial;
                    }
                }
            }
            Message::Resized => self.columns.iter_mut().for_each(|column| {
                if let Width::Resizable {
                    initial, offset
                } = &mut column.width
                {
                    *initial = (*initial + *offset).clamp(50.0, 250.0);
                    *offset = 0.0;
                }
            }),
            Message::ResizeColumnsEnabled(enabled) => self.resize_columns_enabled = enabled,
            Message::FooterEnabled(enabled) => self.footer_enabled = enabled,
            Message::MinWidthEnabled(enabled) => self.min_width_enabled = enabled,
            Message::DarkThemeEnabled(enabled) => {
                if enabled {
                    self.theme = Theme::Dark;
                } else {
                    self.theme = Theme::Light;
                }
            }
        }

        Command::none()
    }

    fn view(&self) -> Element<Self::Message> {
        let table = responsive(|size| {
            let mut table = table::table(
                self.header.clone(),
                self.body.clone(),
                &self.columns,
                &self.rows,
                Message::SyncHeader,
            );

            if self.resize_columns_enabled {
                table = table.on_column_resize(Message::Resizing, Message::Resized);
            }
            if self.footer_enabled {
                table = table.footer(self.footer.clone());
            }
            if self.min_width_enabled {
                table = table.min_width(size.width);
            }

            table.into()
        });

        let content = column![
            checkbox(
                "Resize Columns",
                self.resize_columns_enabled,
                Message::ResizeColumnsEnabled
            ),
            checkbox("Footer", self.footer_enabled, Message::FooterEnabled),
            checkbox(
                "Min Width",
                self.min_width_enabled,
                Message::MinWidthEnabled
            ),
            checkbox(
                "Dark Theme",
                matches!(self.theme, Theme::Dark),
                Message::DarkThemeEnabled
            ),
            table,
        ]
        .spacing(6);

        container(container(content).width(Length::Fill).height(Length::Fill))
            .padding(20)
            .width(Length::Fill)
            .height(Length::Fill)
            .center_x()
            .center_y()
            .into()
    }
}

struct Column {
    letter: Letter,
    width: Width,
}

impl Column {
    fn new(letter: Letter, width: Width) -> Self {
        Self { letter, width }
    }
}

enum Letter {
    A,
    B,
    C,
    D,
    E,
}

impl fmt::Display for Letter {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Letter::A => "A",
            Letter::B => "B",
            Letter::C => "C",
            Letter::D => "D",
            Letter::E => "E",
        }
        .fmt(f)
    }
}

impl<'a, 'b> table::Column<'a, 'b, Message, Renderer> for Column {
    type Row = usize;

    fn header(&'b self, _col_index: usize) -> Element<'a, Message> {
        container(text(format!("Column {}", self.letter)))
            .height(24)
            .center_y()
            .into()
    }

    fn cell(
        &'b self,
        _col_index: usize,
        row_index: usize,
        _row: &'b Self::Row,
    ) -> Element<'a, Message> {
        container(text(format!("Cell {}{row_index}", self.letter)))
            .height(24)
            .center_y()
            .into()
    }

    fn footer(&'b self, _col_index: usize, rows: &'b [Self::Row]) -> Option<Element<'a, Message>> {
        let content = if matches!(self.letter, Letter::C) {
            Element::from(text(format!("Count: {}", rows.len())))
        } else {
            horizontal_space(Length::Fill).into()
        };

        Some(container(content).height(24).center_y().into())
    }

    fn width(&self) -> Width {
        self.width
    }
}
